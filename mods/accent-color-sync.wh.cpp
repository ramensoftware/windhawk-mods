// ==WindhawkMod==
// @id                  accent-color-sync
// @name                Accent Color Sync
// @description         Synchronises OpenGlass and Control Panel color settings
// @description:fr-FR   Synchronisation des couleurs d'OpenGlass et du Panneau de configuration
// @description:es-ES   Sincroniza los colores de OpenGlass y del Panel de control
// @version             1.4
// @author              CatmanFan / Mr._Lechkar
// @github              https://github.com/CatmanFan
// @include             explorer.exe
// @architecture        x86
// @architecture        x86-64
// @compilerOptions     -lcomdlg32 -lversion
// ==/WindhawkMod==

// ==WindhawkModReadme==
/*
Brings back the functionality of the 'Color intensity' slider to Windows 10 using OpenGlass. The mod synchronises OpenGlass's Aero settings with the slider value.

----

## ⚠️ To use this mod, you will need [kfh83](https://github.com/kfh83)'s OpenGlass-legacy fork.

To get this mod to function fully, perform the following steps:
1. Install the OpenGlass-legacy fork; this can be done by compiling the source code from **[the official repo](https://github.com/ALTaleX531/OpenGlass/tree/legacy)**, or by getting an existing binary version from **[this GitHub post](https://github.com/ALTaleX531/OpenGlass/pull/14#issue-2415161314)**.
   * If you are updating this mod from version 1.0, it is required to disable or uninstall any other existing DWM shader software (such as regular OpenGlass or DWMBlurGlass).
2. Afterwards, go to *HKCU\SOFTWARE\Microsoft\Windows\DWM* in the registry and add any one of the three DWORD values of **og_ColorizationColorBalance**, **og_ColorizationAfterglowBalance** and **og_ColorizationBlurBalance** before enabling this mod. These registry values will be handled automatically.

If you are updating this mod from version 1.3, it is recommended to also enable the *Sync with DWM* option from the mod's settings, although this can have some minor bugs (see below).

You may need to try changing the accent color manually if changes do not automatically take effect.

----

### Known bugs:
* ***Sync with DWM* option enabled:**
   * When changing the color intensity in the Control Panel without changing the color itself, the theme preview icon used for the color does not change unless after the theme preview is regenerated by changing the color RGB values or the desktop background.
* Actually closing the Personalization window does not produce the same behaviour as clicking "Cancel" (i.e. the RGB color is changed but the OpenGlass opacity stays the same).
* When using [Explorer7](https://github.com/Erizur/explorer7-releases/), the Start menu may not immediately change in opacity and requires a restart of explorer.exe. This may be fixed with schm1dt's glass POC mod downloadable [here](https://winclassic.net/post/24274).

### Special credits:
* [OjasK](https://github.com/ojask) for his DirectUI reverse-engineering work, part of which was referenced in the making of this mod.
* [ALTaleX](https://github.com/ALTaleX531) for the incredible work on OpenGlass, and on porting the Windows 7 DWM colorization functionality to open-source code with [this formula](https://github.com/ALTaleX531/dwm_colorization_calculator).
*/
// ==/WindhawkModReadme==

// ==WindhawkModSettings==
/*
- syncDWM: TRUE
  $name: Sync with DWM
  $name:fr-FR: Synchroniser avec DWM
  $name:es-ES: Sincronizar con DWM
  $description: Writes the opacity value to DWM's color and afterglow variables. This makes it so that the opacity is also written to the theme alongside the color's RGB. Otherwise, Windows automatically sets it to remain stationary at 0xc4 (196 of 255).
  $description:fr-FR: Sauvegarder la valeur d'opacité aux options de DWM. Cela permet de définir également l'opacité dans le thème simultanément avec les valeurs du RVB. Sinon, Windows le définit en permanence à 0xc4 (196 sur 255).
  $description:es-ES: Guarda el valor de opacidad de OpenGlass en DWM. Esto le permite guardar la opacidad del tema, simultáneamente con los valores RGB. Windows normalmente establece la opacidad siempre en 0xc4 (196 de 255).
*/
// ==/WindhawkModSettings==

#include <winnt.h>
#if _WIN64
#define THISCALL __cdecl
#define STHISCALL L"__cdecl"
#define STDCALL __cdecl
#define SSTDCALL L"__cdecl"
#define STRTOID_NAME L"StrToID"
#else
#define THISCALL __thiscall
#define STHISCALL L"__thiscall"
#define STDCALL __stdcall
#define SSTDCALL L"__stdcall"
#define STRTOID_NAME L"_StrToID@4"
#endif

#include <algorithm>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <windhawk_api.h>
#include <windhawk_utils.h>
#include <winver.h>

struct {
    int opacity;
    bool boolTransparency;
    bool boolSyncDWM;
} settings;

enum class WinVersion { None, Unsupported, Win10, Win11 };
WinVersion winVer;

const std::wstring dwmKey = L"SOFTWARE\\Microsoft\\Windows\\DWM";
const std::wstring opacityValue = L"og_Opacity";

#pragma region ----- Registry functions -----
/**
 * Reads a string value from a registry key within HKCU.
 *
 * @param sk The path to the key, not including "HKCU\".
 * @param v The name of the value.
 * @return The string value if it is found, otherwise `NULL`.
 */
std::wstring read_SZ(std::wstring sk, std::wstring v, std::wstring defaultValue)
{
    const LPCTSTR subkey = sk.c_str();
    const LPCTSTR value = v.c_str();
    WCHAR szBuffer[512];
    DWORD size(sizeof(szBuffer));

    HKEY hKey;
    LONG openRes = RegOpenKeyEx(HKEY_CURRENT_USER, subkey, 0, KEY_READ, &hKey);
    if (openRes == ERROR_SUCCESS) {
        LONG setRes = RegQueryValueEx(hKey, value, 0, NULL, (LPBYTE)&szBuffer, &size);
        RegCloseKey(hKey);

        if (setRes == ERROR_SUCCESS) {
            defaultValue = szBuffer;
        }
    }

    return defaultValue;
}

/**
 * Reads a DWORD value from a registry key within HKCU.
 *
 * @param sk The path to the key, not including "HKCU\".
 * @param v The name of the value.
 * @return The DWORD value if it is found, otherwise `NULL`.
 */
DWORD read_DWORD(std::wstring sk, std::wstring v)
{
    const LPCTSTR subkey = sk.c_str();
    const LPCTSTR value = v.c_str();
    DWORD data(0);
    DWORD size(sizeof(DWORD));

    HKEY hKey;
    LONG openRes = RegOpenKeyEx(HKEY_CURRENT_USER, subkey, 0, KEY_READ, &hKey);
    if (openRes != ERROR_SUCCESS) {
        return NULL;
    }

    LONG setRes = RegQueryValueEx(hKey, value, 0, NULL, reinterpret_cast<LPBYTE>(&data), &size);
    RegCloseKey(hKey);

    if (setRes == ERROR_SUCCESS) {
        return data;
    } else {
        return NULL;
    }
}

/**
 * Checks for the existence of a DWORD value within an HKCU registry key.
 *
 * @param sk The path to the key, not including "HKCU\".
 * @param v The name of the value.
 * @return `TRUE` if found, otherwise `FALSE`.
 */
BOOL exists_DWORD(std::wstring sk, std::wstring v)
{
    const LPCTSTR subkey = sk.c_str();
    const LPCTSTR value = v.c_str();
    DWORD data(0);
    DWORD size(sizeof(DWORD));

    HKEY hKey;
    LONG openRes = RegOpenKeyEx(HKEY_CURRENT_USER, subkey, 0, KEY_ALL_ACCESS, &hKey);
    LONG setRes = RegQueryValueEx(hKey, value, 0, NULL, reinterpret_cast<LPBYTE>(&data), &size);
    RegCloseKey(hKey);

    if (openRes != ERROR_SUCCESS || setRes != ERROR_SUCCESS) {
        return FALSE;
    } else {
        return TRUE;
    }
}

/**
 * Checks for the existence of a registry key within HKCU.
 *
 * @param sk The path to the key, not including "HKCU\".
 * @return `TRUE` if found, otherwise `FALSE`.
 */
BOOL exists_Key(std::wstring sk)
{
    const LPCTSTR subkey = sk.c_str();

    HKEY hKey;
    LONG openRes = RegOpenKeyEx(HKEY_CURRENT_USER, subkey, 0, KEY_ALL_ACCESS, &hKey);
    if (openRes != ERROR_SUCCESS) {
        return FALSE;
    } else {
        return TRUE;
    }
}

/**
 * Writes a DWORD value to a registry key within HKCU.
 *
 * @param sk The path to the key, not including "HKCU\".
 * @param v The name of the value.
 * @param data The DWORD value to write.
 * @return `TRUE` if the operation succeeded, otherwise `FALSE`.
 */
BOOL set_DWORD(std::wstring sk, std::wstring v, unsigned long data)
{
    const LPCTSTR subkey = sk.c_str();
    const LPCTSTR value = v.c_str();

    HKEY hKey;
    LONG openRes = RegOpenKeyEx(HKEY_CURRENT_USER, subkey, 0, KEY_ALL_ACCESS, &hKey);
    if (openRes != ERROR_SUCCESS) {
        Wh_Log(L"Failed to open registry key");
        return FALSE;
    }

    LONG setRes = data < 0 ? RegDeleteValue(hKey, value) : RegSetValueEx(hKey, value, 0, REG_DWORD, (const BYTE*)&data, sizeof(data));
    RegCloseKey(hKey);

    if (setRes == ERROR_SUCCESS) {
        return TRUE;
    } else {
        Wh_Log(L"Failed writing to registry");
        return FALSE;
    }
}
#pragma endregion

#pragma region ----- DWM colorization calculator -----
// ----------------------------------------------------------------------------
// Original code is by ALTaleX !! (converted from Python)
// https://github.com/ALTaleX531/dwm_colorization_calculator/blob/main/main.py
// ----------------------------------------------------------------------------

class hsb {
public:
    float hue; // 0-360
    float saturation; // 0-1
    float brightness; // 0-1

    hsb(float hue, float saturation, float brightness)
        : hue(hue)
        , saturation(saturation)
        , brightness(brightness)
    {
    }

    void log() { Wh_Log(L"[H: %d, S: %d, B: %d]", hue, saturation, brightness); }
};

// Just the plain ARGB value
// **************************************
class argb {
public:
    int value;

    argb(int value)
        : value(value)
    {
    }

    int get_a() const { return (value & 0xFF000000) >> 24; }
    int get_r() const { return (value & 0x00FF0000) >> 16; }
    int get_g() const { return (value & 0x0000FF00) >> 8; }
    int get_b() const { return (value & 0x000000FF); }

    static int from_argb_channel(float a, float r, float g, float b) { return ((static_cast<int>(a * 255.0 + 0.5) & 0xFF) << 24) | ((static_cast<int>(r * 255.0 + 0.5) & 0xFF) << 16) | ((static_cast<int>(g * 255.0 + 0.5) & 0xFF) << 8) | ((static_cast<int>(b * 255.0 + 0.5) & 0xFF)); }
};

// Colorization color, which permits ARGB color to be converted to DWM parameters
// **************************************
class colorization_color : public argb {
public:
    colorization_color(int value)
        : argb(value)
    {
    }

    static colorization_color from_hsb(const hsb& color, float intensity)
    {
        float r, g, b;

        if (color.saturation == 0.0) {
            r = g = b = color.brightness;
        } else {
            float value = color.hue / 60.0;
            float difference = value - static_cast<int>(value);

            if (color.hue > 0.0 && color.hue <= 60.0) {
                g = (1.0 - (1.0 - difference) * color.saturation) * color.brightness;
                b = (1.0 - color.saturation) * color.brightness;
                r = color.brightness;
            } else if (color.hue > 60.0 && color.hue <= 120.0) {
                r = (1.0 - difference * color.saturation) * color.brightness;
                g = color.brightness;
                b = (1.0 - color.saturation) * color.brightness;
            } else if (color.hue > 120.0 && color.hue <= 180.0) {
                r = (1.0 - color.saturation) * color.brightness;
                g = color.brightness;
                b = (1.0 - (1.0 - difference) * color.saturation) * color.brightness;
            } else if (color.hue > 180.0 && color.hue <= 240.0) {
                r = (1.0 - color.saturation) * color.brightness;
                g = (1.0 - difference * color.saturation) * color.brightness;
                b = color.brightness;
            } else if (color.hue > 240.0 && color.hue <= 300.0) {
                r = (1.0 - (1.0 - difference) * color.saturation) * color.brightness;
                g = (1.0 - color.saturation) * color.brightness;
                b = color.brightness;
            } else /* if (color.hue > 300.0 && color.hue <= 360.0) */ {
                r = color.brightness;
                g = (1.0 - color.saturation) * color.brightness;
                b = (1.0 - difference * color.saturation) * color.brightness;
            }
        }

        return colorization_color(argb::from_argb_channel(intensity, r, g, b));
    }

    float get_intensity() const { return static_cast<float>(get_a()) / 255.0; }

    hsb get_hsb_color() const
    {
        float r = static_cast<float>(get_r()) / 255.0;
        float g = static_cast<float>(get_g()) / 255.0;
        float b = static_cast<float>(get_b()) / 255.0;

        float brightness = std::max({ r, g, b });
        float darkness = std::min({ r, g, b });
        float range_value = brightness - darkness;
        float saturation, value;

        if (brightness == 0.0 || range_value == 0.0) {
            saturation = 0.0;
            value = 0.0;
        } else {
            saturation = range_value / brightness;
            if (r == brightness) {
                value = (g - b) / range_value;
            } else if (g == brightness) {
                value = (b - r) / range_value + 2.0;
            } else {
                value = (r - g) / range_value + 4.0;
            }
        }

        float hue = value * 60.0;
        if (hue < 0.0)
            hue += 360.0;

        return hsb(hue, saturation, brightness);
    }
};

// Now we get to the good stuff
// **************************************
class dwm_colorization_parameters {
public:
    argb color;
    argb afterglow;
    int color_balance;
    int afterglow_balance;
    int blur_balance;
    int glass_reflection_intensity;
    bool opaque_blend;

    dwm_colorization_parameters(argb color = argb(0x6b74b8fc), argb afterglow = argb(0x6b74b8fc), int color_balance = 8, int afterglow_balance = 43, int blur_balance = 49, int glass_reflection_intensity = 50, bool opaque_blend = false)
        : color(color)
        , afterglow(afterglow)
        , color_balance(color_balance)
        , afterglow_balance(afterglow_balance)
        , blur_balance(blur_balance)
        , glass_reflection_intensity(glass_reflection_intensity)
        , opaque_blend(opaque_blend)
    {
    }

    void log()
    {
        Wh_Log(L"[Color:               %8x]", color);
        Wh_Log(L"[Afterglow:           %8x]", afterglow);
        Wh_Log(L"[Balance (color):     %d]", color_balance);
        Wh_Log(L"[Balance (afterglow): %d]", afterglow_balance);
        Wh_Log(L"[Balance (blur):      %d]", blur_balance);
        Wh_Log(L"{Glass reflection intensity: %d}", glass_reflection_intensity);
        Wh_Log(L"{Opaque blend: %d}", opaque_blend);
    }

    DWORD convert_colorization_parameters_to_argb()
    {
        int balance = 0;

        if (opaque_blend) {
            balance = color_balance;
        } else if (blur_balance < 50) {
            if (blur_balance <= 23) {
                balance = color_balance + 25;
            } else {
                balance = 95 - afterglow_balance;
            }
        } else {
            balance = 100 - blur_balance;
        }

        return color.value & (0xFFFFFF | ((static_cast<int>((static_cast<float>(balance - 10) * 0.75 / 100.0 + 0.1) * 255.0 + 0.5) & 0xFF) << 24));
    }

    colorization_color to_colorization_color()
    {
        int argb_color = 0;

        if ((color.value & 0xFF000000) == 0xFF000000) {
            argb_color = convert_colorization_parameters_to_argb();
        } else {
            argb_color = color.value;
        }

        return colorization_color(argb_color);
    }

    colorization_color calculate_dwm_color()
    {
        float afterglow_balance = static_cast<float>(this->afterglow_balance) / 100.0;
        float color_balance = static_cast<float>(this->color_balance) / 100.0;

        float color_r = static_cast<float>(color.get_r()) / 255.0;
        float color_g = static_cast<float>(color.get_g()) / 255.0;
        float color_b = static_cast<float>(color.get_b()) / 255.0;

        float afterglow_r = static_cast<float>(afterglow.get_r()) / 255.0;
        float afterglow_g = static_cast<float>(afterglow.get_g()) / 255.0;
        float afterglow_b = static_cast<float>(afterglow.get_b()) / 255.0;

        float result_a = std::max(0.0f, (1.0f - afterglow_balance) - (static_cast<float>(blur_balance) / 100.0f));
        float brightness = (color_g * 0.7152 + color_r * 0.2126 + color_b * 0.0722) * afterglow_balance * color_balance;

        float result_r = afterglow_r * brightness + color_r * color_balance;
        float result_g = afterglow_g * brightness + color_g * color_balance;
        float result_b = afterglow_b * brightness + color_b * color_balance;

        return colorization_color(argb::from_argb_channel(result_a, result_r, result_g, result_b));
    }
};
#pragma endregion

#pragma region ----- DWM colorization calculation: Functions -----
colorization_color old = NULL;
colorization_color current = NULL;
hsb HSB = current.get_hsb_color();
dwm_colorization_parameters dwmSettings;
DWORD modified;

int intensitySliderMin = 10;
int intensitySliderMax = 85;
int valueTo100(int x) { return x - intensitySliderMin / (intensitySliderMax - intensitySliderMin) * 100; }
int valueFrom100(int x) { return (x / 100) * (intensitySliderMax - intensitySliderMin) + intensitySliderMin; }
#pragma endregion

DWORD readColor()
{
    const std::wstring value = L"ColorizationColor";

    if (!exists_DWORD(dwmKey, value))
        return 0xFF000000;
    else
        return read_DWORD(dwmKey, value);
}

void loadColorValues(DWORD input)
{
    current = colorization_color(input);
    HSB = current.get_hsb_color();
}

// ----------------------------------------------------------------------------
// Taken from "to_dwm_colorization_parameters" function (again, by ALTaleX):
// https://github.com/ALTaleX531/dwm_colorization_calculator/blob/main/main.py#L110
// ----------------------------------------------------------------------------
void calculateIntensity(DWORD self)
{
    int balance = int((float((self >> 24) & 0xFF) / 255.0f - 0.1f) / 0.75f * 100.0f + 10.0f);
    dwmSettings = dwm_colorization_parameters(self, self, 0, 0, 0, 50, !settings.boolTransparency);

    if (dwmSettings.opaque_blend) {
        dwmSettings.afterglow_balance = 10;
        dwmSettings.color_balance = balance - dwmSettings.afterglow_balance;
        dwmSettings.blur_balance = 100 - balance;
    }

    else if (balance < 50) {
        dwmSettings.color_balance = 5;
        dwmSettings.blur_balance = 100 - balance;
        dwmSettings.afterglow_balance = (100 - dwmSettings.color_balance) - dwmSettings.blur_balance;
    }

    else if (balance >= 95) {
        dwmSettings.afterglow_balance = 0;
        dwmSettings.color_balance = balance - 25;
        dwmSettings.blur_balance = 100 - dwmSettings.color_balance;
    }

    else {
        dwmSettings.afterglow_balance = 95 - balance;
        dwmSettings.blur_balance = 50 - ((balance - 50) >> 1);
        dwmSettings.color_balance = 100 - dwmSettings.afterglow_balance - dwmSettings.blur_balance;
    }
}

int opacity = -1;
/**
 * Writes the OpenGlass opacity value to DWM's color and afterglow values in registry.
 */
void bruteforceOpacity()
{
    if (!settings.boolSyncDWM)
        return;

    argb dwm(readColor());
    argb og(dwmSettings.to_colorization_color().value);
    if (dwm.value == 0x52fadc0e) dwm.value = 0x54fadc0e; // Sun
    if (dwm.value == og.value) return;
    int opacity = og.get_a();

    // Hotfixes to match with Windows 7 accent colors
    if (opacity == 0x69 || opacity == 0x6a)
        opacity = 0x6b;
    if (opacity == 0xa6 || opacity == 0xa7)
        opacity = 0xa8;
    if (opacity == 0x67)
        opacity = 0x66;
    if (opacity == 0x6e || opacity == 0x6f)
        opacity = 0x70;
    if (dwm.value == 0x54fadc0e)
        opacity = 0x54;

    DWORD New = (dwm.value & 0x00ffffff) | (opacity << 24);
    set_DWORD(dwmKey, L"ColorizationColor", New);
    set_DWORD(dwmKey, L"ColorizationAfterglow", New);

    dwmSettings.color = dwmSettings.afterglow = New;
}

/**
 * Calculates the color, afterglow and blur intensity values from an integer out of 100, then writes them to the registry for use with OpenGlass.
 * @param bruteforce Determines whether to also simultaneously bruteforce the opacity value to DWM.
 */
void writeColorizationBalance(bool bruteforce = FALSE)
{
    if (settings.opacity < 0 || settings.opacity > 100)
        settings.opacity = 42; // 40.7853080838;
    if (opacity < 0 || opacity > 100)
        opacity = settings.opacity;
    set_DWORD(dwmKey, opacityValue, opacity);

    float alpha = opacity / 100.0f;

    // *********************************************
    // Min: 26, max: 217
    // NOTE: Changing the ColorizationColor and Afterglow also affects the intensity slider
    // *********************************************
    loadColorValues((current.value & 0x00FFFFFF) | ((static_cast<int>(alpha * 255.0 + 0.5) & 0xFF) << 24));
    calculateIntensity(current.value);

    // *********************************************
    // Actually do the registry editing
    // *********************************************
    set_DWORD(dwmKey, L"og_ColorizationColorBalance", dwmSettings.color_balance);
    set_DWORD(dwmKey, L"og_ColorizationAfterglowBalance", dwmSettings.afterglow_balance);
    set_DWORD(dwmKey, L"og_ColorizationBlurBalance", dwmSettings.blur_balance);

    // Other registry values
    set_DWORD(dwmKey, L"GlassOpacity", 0); // settings.boolTransparency ? 0 : 100);
    set_DWORD(dwmKey, L"GlassType", 1);    // settings.boolTransparency ? 1 : 0);

    if (bruteforce)
		bruteforceOpacity();

    PostMessage(FindWindow(TEXT("dwm"), nullptr), WM_DWMCOLORIZATIONCOLORCHANGED, 0, 0);
}

#pragma region ----- DirectUI hooks -----
typedef ATOM WINAPI (*StrToId_T)(unsigned const short*);
StrToId_T StrToID;

// Pointers to DUI elements
intptr_t intensitySlider = 0;
intptr_t okButton = 0;
intptr_t cancelButton = 0;

typedef unsigned short (*THISCALL Element_GetID_T)(class Element*, void*);
Element_GetID_T Element_GetID;

void (*THISCALL Element_OnPropertyChanged)(class Element*, class PropertyInfo const*, int, class Value*, class Value*);
void THISCALL Element_OnPropertyChanged_hook(class Element* This, class PropertyInfo const* prop, int integer, class Value* valueA, class Value* valueB)
{
    Element_OnPropertyChanged(This, prop, integer, valueA, valueB);
    intptr_t ptr = reinterpret_cast<intptr_t>(This);
    if (ptr <= 0) return;

    ATOM id = Element_GetID(This, &This);

    if (intensitySlider != id && id == StrToID((unsigned const short*)L"IntensitySlider"))
        intensitySlider = ptr;

    // *********************************************
    // The bruteforcing here has to be done so that the default alpha color value is overwritten
    // *********************************************
    else if (okButton != id && id == StrToID((unsigned const short*)L"OkButton")) {
        okButton = ptr;
        bruteforceOpacity();
    }
    else if (cancelButton != id && id == StrToID((unsigned const short*)L"CancelButton")) {
        cancelButton = ptr;
        bruteforceOpacity();
    }
}

long (*THISCALL CCTrackBar_SetThumbPosition)(class CCTrackBar*, int);
long THISCALL CCTrackBar_SetThumbPosition_hook(class CCTrackBar* This, int value)
{
    intptr_t ptr = reinterpret_cast<intptr_t>(This);

    // Track bar value
    if (ptr > 0 && ptr == intensitySlider) {
        opacity = value;
        writeColorizationBalance();
    }

    return CCTrackBar_SetThumbPosition(This, value);
}

/**
 * -------------------------
 * Function for permanent hooking of opacity to DWM when OK/Cancel is clicked
 * -------------------------
 */
typedef void (*THISCALL CCPushButton_OnSelectedPropertyChanged_T)(class CCPushButton*, void*);
CCPushButton_OnSelectedPropertyChanged_T CCPushButton_OnSelectedPropertyChanged;
void THISCALL CCPushButton_OnSelectedPropertyChanged_hook(class CCPushButton* This, void* that)
{
    intptr_t ptr = reinterpret_cast<intptr_t>(This);

    // OK button
    if (ptr > 0 && ptr == okButton) {
        settings.opacity = opacity;
        bruteforceOpacity();
    }

    // Cancel button
    else if (ptr > 0 && ptr == cancelButton) {
        opacity = settings.opacity;
		loadColorValues(old.value);
        writeColorizationBalance(TRUE);
		
        if (intensitySlider > 0)
            CCTrackBar_SetThumbPosition(reinterpret_cast<class CCTrackBar*>(intensitySlider), opacity);
    }

    CCPushButton_OnSelectedPropertyChanged(This, that);
}
#pragma endregion

#pragma region ##ThemeUI hooks##

enum DWMPGLASSATTRIBUTE : INT {
    DWMPGA_TRANSPARENCY_ALLOWED = 0x0,
    DWMPGA_TRANSPARENCY_DISALLOWED = 0x1,
    DWMPGA_NO_GLASS = 0x2,
    DWMPGA_LAST = 0x3,
};

/**
 * -------------------------
 * Function for setting OpenGlass opacity when the theme is changed from the Control Panel
 * -------------------------
 */
long (*STDCALL SetDwmColorizationColor)(unsigned long, enum DWMPGLASSATTRIBUTE, int);
long STDCALL SetDwmColorizationColor_hook(unsigned long color, enum DWMPGLASSATTRIBUTE attribute, int integer)
{
    settings.opacity = opacity = round(argb(color).get_a() / 255.0 * 100.0);
    old = colorization_color(color);
	loadColorValues(old.value);
    writeColorizationBalance();

    return SetDwmColorizationColor(color, attribute, integer);
}
#pragma endregion

WindhawkUtils::SYMBOL_HOOK dui70dll_hooks[] = {
    {
        {STRTOID_NAME},
        (void**)&StrToID,
    },

    {
        {L"public: unsigned short " STHISCALL " DirectUI::Element::GetID(void)"},
        (void**)&Element_GetID
    },

    {
        {L"public: virtual void " STHISCALL " DirectUI::Element::OnPropertyChanged(struct DirectUI::PropertyInfo const *,int,class DirectUI::Value *,class DirectUI::Value *)"},
        (void**)&Element_OnPropertyChanged,
        (void*)Element_OnPropertyChanged_hook
    },

    {
        {L"public: long " STHISCALL " DirectUI::CCTrackBar::SetThumbPosition(int)"},
        (void**)&CCTrackBar_SetThumbPosition,
        (void*)CCTrackBar_SetThumbPosition_hook
    },

    {
        {L"public: virtual void " STHISCALL " DirectUI::CCPushButton::OnSelectedPropertyChanged(void)"},
        (void**)&CCPushButton_OnSelectedPropertyChanged,
        (void*)&CCPushButton_OnSelectedPropertyChanged_hook
    }
};

WindhawkUtils::SYMBOL_HOOK themeuidll_hooks[] = {
    {
        {L"long " SSTDCALL " SetDwmColorizationColor(unsigned long,enum DWMPGLASSATTRIBUTE,int)"},
        (void**)&SetDwmColorizationColor,
        (void*)SetDwmColorizationColor_hook
    }
};

typedef NTSTATUS(NTAPI* RtlGetVersion_t)(PRTL_OSVERSIONINFOW);
RtlGetVersion_t RtlGetVersion;
WinVersion getWinVer()
{
    HMODULE hNtDll = LoadLibraryW(L"ntdll.dll");
    if (!hNtDll)
        return WinVersion::None;

    RtlGetVersion = (RtlGetVersion_t)GetProcAddress(hNtDll, "RtlGetVersion");
    if (!RtlGetVersion)
        return WinVersion::None;

    RTL_OSVERSIONINFOW osv = { sizeof(RTL_OSVERSIONINFOW) };
    if (RtlGetVersion(&osv) == 0x00) {
        WORD major = osv.dwMajorVersion;
        WORD minor = osv.dwMinorVersion;
        WORD build = osv.dwBuildNumber;
        Wh_Log(L"Current OS version: %u.%u (build %u)", major, minor, build);

        switch (major) {
			case 10:
				if (build < 22000)
					return WinVersion::Win10;
				else
					return WinVersion::Win11;
				break;

			default:
				return WinVersion::Unsupported;
        }
    }

    return WinVersion::None;
}

BOOL isOpenGlassInstalled(bool strict = FALSE)
{
    return strict ? exists_DWORD(dwmKey, L"og_ColorizationColorBalance") && exists_DWORD(dwmKey, L"og_ColorizationAfterglowBalance") && exists_DWORD(dwmKey, L"og_ColorizationBlurBalance")
                  : exists_DWORD(dwmKey, L"og_ColorizationColorBalance") || exists_DWORD(dwmKey, L"og_ColorizationAfterglowBalance") || exists_DWORD(dwmKey, L"og_ColorizationBlurBalance");
}

BOOL LoadSettings()
{
    bool regSetup = FALSE;

    // *********************************************
    // Check for OpenGlass installation
    // *********************************************
    if (!isOpenGlassInstalled()) {
        Wh_Log(L"HALT: OpenGlass Legacy was not detected");
        return FALSE;
    } else {
        regSetup = !isOpenGlassInstalled(TRUE);
    }

    // *********************************************
    // Check/load from opacity DWORD in registry
    // *********************************************
    if (!exists_DWORD(dwmKey, opacityValue))
        regSetup = TRUE;
    else
        settings.opacity = read_DWORD(dwmKey, opacityValue);

    // *********************************************
    // Setup if those checks were not fully met
    // *********************************************
    if (regSetup) {
        Wh_Log(L"Setting up registry");
		
        settings.opacity = 42;
        set_DWORD(dwmKey, L"og_ColorizationColorBalance", 0x08);
        set_DWORD(dwmKey, L"og_ColorizationAfterglowBalance", 0x2b);
        set_DWORD(dwmKey, L"og_ColorizationBlurBalance", 0x31);

        if (!set_DWORD(dwmKey, opacityValue, settings.opacity))
            return FALSE;
        if (!exists_DWORD(dwmKey, opacityValue))
            return FALSE;
    }
	
    loadColorValues(readColor());
	old = current;

    settings.boolTransparency = TRUE;
    settings.boolSyncDWM = Wh_GetIntSetting(L"syncDWM");

    return TRUE;
}

BOOL Wh_ModSettingsChanged(BOOL* bReload)
{
    Wh_Log(L"Settings changed");

    *bReload = TRUE;
    return TRUE;
}

BOOL Wh_ModInit()
{
    std::wstring username = read_SZ(L"Volatile Environment", L"USERNAME", L"???");
    if (username == L"???") {
        Wh_Log(L"HALT: Local username not detected");
        return FALSE;
    }

    winVer = getWinVer();
    if (winVer == WinVersion::None) {
        Wh_Log(L"HALT: Invalid OS version");
        return FALSE;
    }
    switch (winVer) {
		case WinVersion::Unsupported:
			Wh_Log(L"HALT: Cannot run on Windows 8.1 or earlier");
			return FALSE;

		default:
			break;
    }

    if (!LoadSettings()) {
        Wh_Log(L"HALT: Failed to load settings");
        return FALSE;
    }

    HMODULE hDui = LoadLibraryW(L"dui70.dll");
    if (hDui) {
        if (!WindhawkUtils::HookSymbols(hDui, dui70dll_hooks, ARRAYSIZE(dui70dll_hooks))) {
            Wh_Log(L"HALT: Failed to hook symbols from dui70.dll");
            return FALSE;
        }
    } else {
        Wh_Log(L"HALT: Failed to load dui70.dll");
        return FALSE;
    }

    HMODULE hThemeUi = LoadLibraryW(L"themeui.dll");
    if (hThemeUi) {
        if (!WindhawkUtils::HookSymbols(hThemeUi, themeuidll_hooks, ARRAYSIZE(themeuidll_hooks))) {
            Wh_Log(L"HALT: Failed to hook symbols from themeui.dll");
            return FALSE;
        }
    } else {
        Wh_Log(L"HALT: Failed to load themeui.dll");
        return FALSE;
    }

    writeColorizationBalance();
    return TRUE;
}