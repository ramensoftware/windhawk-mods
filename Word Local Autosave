// ==WindhawkMod==
// @id              word-local-autosave
// @name            Word Local AutoSave
// @description     Enables AutoSave functionality for local documents in Microsoft Word by sending Ctrl+S
// @version         0.0.1
// @author          communism420
// @github          https://github.com/communism420
// @include         WINWORD.EXE
// ==/WindhawkMod==

// ==WindhawkModReadme==
/*
# Word Local AutoSave

This mod enables automatic saving for locally stored Word documents, similar to 
how AutoSave works with OneDrive files.

## How it works
- Hooks TranslateMessage to monitor keyboard input
- After detecting document changes, waits for a configurable delay
- Sends Ctrl+S keystroke to save the document automatically

## Settings
- **Save Delay**: How long to wait (in milliseconds) after detecting changes before saving
- **Minimum Time Between Saves**: Prevents excessive saving. Set to 0 to disable this limit.
*/
// ==/WindhawkModReadme==

// ==WindhawkModSettings==
/*
- saveDelay: 1000
  $name: Save Delay (ms)
  $description: Delay in milliseconds before auto-saving after a change is detected (minimum 100ms)
- minTimeBetweenSaves: 0
  $name: Minimum Time Between Saves (ms)
  $description: Minimum time between consecutive saves. Set to 0 to disable this limit and allow saving as frequently as possible.
*/
// ==/WindhawkModSettings==

#include <windows.h>

// Settings
struct {
    int saveDelay;
    int minTimeBetweenSaves;
} g_settings;

// Global state
UINT_PTR g_saveTimerId = 0;
DWORD g_lastSaveTime = 0;
DWORD g_lastInputTime = 0;
bool g_isSendingCtrlS = false;

// Original function pointer
typedef BOOL (WINAPI *TranslateMessage_t)(const MSG*);
TranslateMessage_t g_originalTranslateMessage = nullptr;

// Forward declarations
void ScheduleSave();
void PerformSave();
void SendCtrlS();

// Send Ctrl+S keystroke
void SendCtrlS() {
    g_isSendingCtrlS = true;
    
    INPUT inputs[4] = {};
    
    // Press Ctrl
    inputs[0].type = INPUT_KEYBOARD;
    inputs[0].ki.wVk = VK_CONTROL;
    inputs[0].ki.dwFlags = 0;
    
    // Press S
    inputs[1].type = INPUT_KEYBOARD;
    inputs[1].ki.wVk = 'S';
    inputs[1].ki.dwFlags = 0;
    
    // Release S
    inputs[2].type = INPUT_KEYBOARD;
    inputs[2].ki.wVk = 'S';
    inputs[2].ki.dwFlags = KEYEVENTF_KEYUP;
    
    // Release Ctrl
    inputs[3].type = INPUT_KEYBOARD;
    inputs[3].ki.wVk = VK_CONTROL;
    inputs[3].ki.dwFlags = KEYEVENTF_KEYUP;
    
    UINT sent = SendInput(4, inputs, sizeof(INPUT));
    
    g_isSendingCtrlS = false;
    
    Wh_Log(L"Sent Ctrl+S for auto-save (sent %u inputs)", sent);
}

// Timer callback for delayed save
void CALLBACK SaveTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime) {
    KillTimer(NULL, g_saveTimerId);
    g_saveTimerId = 0;
    
    DWORD currentTime = GetTickCount();
    
    // Check minimum time between saves (only if enabled, i.e. > 0)
    if (g_settings.minTimeBetweenSaves > 0 && g_lastSaveTime > 0) {
        if ((currentTime - g_lastSaveTime) < (DWORD)g_settings.minTimeBetweenSaves) {
            Wh_Log(L"Skipping save - too soon since last save");
            return;
        }
    }
    
    // Check if there was recent input
    if (g_lastInputTime == 0) {
        return;
    }
    
    Wh_Log(L"Performing auto-save...");
    
    // Send Ctrl+S
    SendCtrlS();
    
    g_lastSaveTime = currentTime;
    g_lastInputTime = 0;
}

// Schedule a save operation
void ScheduleSave() {
    g_lastInputTime = GetTickCount();
    
    // Kill existing timer if any
    if (g_saveTimerId != 0) {
        KillTimer(NULL, g_saveTimerId);
        g_saveTimerId = 0;
    }
    
    // Set new timer
    g_saveTimerId = SetTimer(NULL, 0, g_settings.saveDelay, SaveTimerProc);
    
    if (g_saveTimerId == 0) {
        Wh_Log(L"Failed to set timer: %d", GetLastError());
    }
}

// Check if a key is an editing key that modifies the document
bool IsEditingKey(WPARAM wParam) {
    // Ignore if we're sending Ctrl+S ourselves
    if (g_isSendingCtrlS) {
        return false;
    }
    
    bool ctrlPressed = (GetAsyncKeyState(VK_CONTROL) & 0x8000) != 0;
    bool altPressed = (GetAsyncKeyState(VK_MENU) & 0x8000) != 0;
    
    // Ignore Ctrl+S (manual save) - update last save time
    if (ctrlPressed && wParam == 'S') {
        g_lastSaveTime = GetTickCount();
        g_lastInputTime = 0;
        if (g_saveTimerId != 0) {
            KillTimer(NULL, g_saveTimerId);
            g_saveTimerId = 0;
        }
        Wh_Log(L"Manual save detected, resetting timer");
        return false;
    }
    
    // Ctrl combinations that modify document
    if (ctrlPressed) {
        if (wParam == 'V' || wParam == 'X' || wParam == 'Z' || wParam == 'Y') {
            Wh_Log(L"Edit key detected: Ctrl+%c", (char)wParam);
            return true;
        }
        return false;
    }
    
    // Ignore Alt combinations
    if (altPressed) {
        return false;
    }
    
    // Printable characters
    if (wParam >= 0x20 && wParam <= 0x7E) {
        return true;
    }
    
    // Special editing keys
    switch (wParam) {
        case VK_BACK:
        case VK_DELETE:
        case VK_RETURN:
        case VK_TAB:
            Wh_Log(L"Edit key detected: VK=%d", (int)wParam);
            return true;
    }
    
    return false;
}

// Hooked TranslateMessage
BOOL WINAPI TranslateMessage_Hook(const MSG* lpMsg) {
    if (lpMsg && (lpMsg->message == WM_KEYDOWN || lpMsg->message == WM_CHAR)) {
        if (lpMsg->message == WM_KEYDOWN && IsEditingKey(lpMsg->wParam)) {
            ScheduleSave();
        }
    }
    
    return g_originalTranslateMessage(lpMsg);
}

// Load settings
void LoadSettings() {
    g_settings.saveDelay = Wh_GetIntSetting(L"saveDelay");
    g_settings.minTimeBetweenSaves = Wh_GetIntSetting(L"minTimeBetweenSaves");
    
    // Minimal validation - just prevent negative values and too small delay
    if (g_settings.saveDelay < 100) g_settings.saveDelay = 100;
    if (g_settings.minTimeBetweenSaves < 0) g_settings.minTimeBetweenSaves = 0;
    
    Wh_Log(L"Settings loaded: saveDelay=%d, minTimeBetweenSaves=%d (0=disabled)",
           g_settings.saveDelay, g_settings.minTimeBetweenSaves);
}

// Mod initialization
BOOL Wh_ModInit() {
    Wh_Log(L"Word Local AutoSave mod v3.1 initializing...");
    
    LoadSettings();
    
    // Hook TranslateMessage
    HMODULE user32 = GetModuleHandleW(L"user32.dll");
    if (!user32) {
        Wh_Log(L"Failed to get user32.dll handle");
        return FALSE;
    }
    
    void* translateMessageAddr = (void*)GetProcAddress(user32, "TranslateMessage");
    if (!translateMessageAddr) {
        Wh_Log(L"Failed to get TranslateMessage address");
        return FALSE;
    }
    
    Wh_Log(L"TranslateMessage found at %p", translateMessageAddr);
    
    if (!Wh_SetFunctionHook(translateMessageAddr, (void*)TranslateMessage_Hook, (void**)&g_originalTranslateMessage)) {
        Wh_Log(L"Failed to hook TranslateMessage");
        return FALSE;
    }
    
    Wh_Log(L"Word Local AutoSave mod initialized successfully!");
    
    return TRUE;
}

// Mod uninitialization
void Wh_ModUninit() {
    Wh_Log(L"Word Local AutoSave mod uninitializing...");
    
    // Kill timer
    if (g_saveTimerId != 0) {
        KillTimer(NULL, g_saveTimerId);
        g_saveTimerId = 0;
    }
    
    Wh_Log(L"Word Local AutoSave mod uninitialized");
}

// Settings changed callback
void Wh_ModSettingsChanged() {
    Wh_Log(L"Settings changed, reloading...");
    LoadSettings();
}
